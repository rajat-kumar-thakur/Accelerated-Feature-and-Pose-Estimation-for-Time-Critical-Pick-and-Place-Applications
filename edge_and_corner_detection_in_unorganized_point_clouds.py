# -*- coding: utf-8 -*-
"""Edge and Corner Detection in Unorganized Point Clouds.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OlzhwdyKTX7qXuLnWoyCemBMsf-AFCSV

# Edge and Corner Detection in Unorganized Point Clouds for Robotic Pick and Place Applications
"""

!pip install pyntcloud
!pip install open3d

# Commented out IPython magic to ensure Python compatibility.
# %%time
# from pyntcloud import PyntCloud
# import pandas as pd
# import matplotlib.pyplot as plt
# from scipy.spatial import KDTree
# from sklearn.linear_model import RANSACRegressor
# from mpl_toolkits.mplot3d import Axes3D
# import matplotlib.pyplot as plt
# import numpy as np
# import open3d as o3d
# from sklearn.cluster import DBSCAN
# from collections import deque
# from itertools import combinations

# Commented out IPython magic to ensure Python compatibility.
# %%time
# file_path = "/content/drive/MyDrive/Edge and Corner Detection in Unorganized Point Clouds/ArtificialPointClouds/Cube30KSharpEdge.pcd"
# cloud = PyntCloud.from_file(file_path)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# df = cloud.points
# 
# fig = plt.figure(figsize=(8, 6))
# ax = fig.add_subplot(111, projection='3d')
# ax.scatter(df['x'], df['y'], df['z'], s=0.5)
# ax.set_xlabel('X')
# ax.set_ylabel('Y')
# ax.set_zlabel('Z')
# plt.title("Point Cloud")
# plt.show()

"""## 1. Edge Points Extraction"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# def compute_edge_mask(pcd: PyntCloud, rs: float, th: float):
#     pts = pcd.points[['x','y','z']].values
#     N   = pts.shape[0]
#     tree = KDTree(pts)
# 
#     scores = np.zeros(N, dtype=float)
#     mask   = np.zeros(N, dtype=bool)
# 
#     for i in range(N):
#         idx = tree.query_ball_point(pts[i], rs)
#         idx = [j for j in idx if j != i]
#         k   = len(idx)
#         if k < 3:
#             continue
# 
#         nbrs = pts[idx]
#         diffs = nbrs - pts[i]
#         norms = np.linalg.norm(diffs, axis=1)
#         valid = norms > 0
#         u     = diffs[valid] / norms[valid][:,None]
#         if u.shape[0] < 3:
#             continue
# 
#         R   = u.sum(axis=0)
#         Rn  = np.linalg.norm(R)
#         if Rn == 0:
#             continue
#         Rhat = R / Rn
# 
#         dots     = u.dot(Rhat)
#         score_i  = dots.mean()
#         scores[i] = score_i
#         mask[i]   = (score_i > th)
# 
#     return mask, scores

# Commented out IPython magic to ensure Python compatibility.
# %%time
# rs = 0.2
# th = 0.42
# 
# edge_mask, edge_scores = compute_edge_mask(cloud, rs, th)
# 
# xyz = cloud.points[['x','y','z']].values
# x, y, z = xyz.T
# 
# fig = plt.figure(figsize=(8,6))
# ax  = fig.add_subplot(111, projection='3d')
# 
# ax.scatter(x[~edge_mask], y[~edge_mask], z[~edge_mask],
#            c='blue', s=1, label='Non‚Äêedges')
# ax.scatter(x[ edge_mask], y[ edge_mask], z[ edge_mask],
#            c='red',       s=2, label='Edges')
# 
# ax.set_xlabel('X'); ax.set_ylabel('Y'); ax.set_zlabel('Z')
# plt.legend()
# plt.title("Point Cloud with Edge Points Highlighted")
# plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %%time
# df = cloud.points.copy()
# 
# df = df.dropna(subset=['x','y','z']).reset_index(drop=True)
# 
# colors = np.zeros((len(df), 3), dtype=np.uint8)
# colors[~edge_mask[df.index]] = [0,   0, 255]
# colors[ edge_mask[df.index]] = [255, 0,   0]
# 
# df[['red','green','blue']] = pd.DataFrame(colors, index=df.index)
# 
# colored_cloud = PyntCloud(df)
# 
# xyz = colored_cloud.points[['x','y','z']].values
# 
# pcd_o3d = o3d.geometry.PointCloud()
# pcd_o3d.points = o3d.utility.Vector3dVector(xyz)
# 
# if all(c in colored_cloud.points.columns for c in ('red','green','blue')):
#     rgb255 = colored_cloud.points[['red','green','blue']].values
#     rgb01  = rgb255.astype(float) / 255.0
#     pcd_o3d.colors = o3d.utility.Vector3dVector(rgb01)
# 
# output_ply = "colored_cloud_output.ply"
# o3d.io.write_point_cloud(output_ply, pcd_o3d, write_ascii=True)

"""## 2. Estimating the Length of Edges"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# def ransac_line(pts, n_iter=200, dist_thr=0.01, min_inliers=30):
#     best_inliers = []
#     best_model = None
#     N = len(pts)
#     for _ in range(n_iter):
#         i1,i2 = np.random.choice(N,2,replace=False)
#         p1,p2 = pts[i1], pts[i2]
#         v = p2-p1; vn = np.linalg.norm(v)
#         if vn==0: continue
#         vh = v/vn
#         diffs = pts - p1
#         proj  = (diffs.dot(vh)[:,None])*vh[None,:]
#         dists = np.linalg.norm(diffs - proj, axis=1)
#         inl = np.where(dists<dist_thr)[0]
#         if len(inl)>len(best_inliers):
#             best_inliers, best_model = inl, (p1,vh)
#     if best_model is None or len(best_inliers)<min_inliers:
#         return None, None
#     return best_model, best_inliers

# Commented out IPython magic to ensure Python compatibility.
# %%time
# def get_reference_index(pts, rs):
#     tree = KDTree(pts)
#     counts = [len(tree.query_ball_point(pts[i], rs)) for i in range(len(pts))]
#     return int(np.argmax(counts))

# Commented out IPython magic to ensure Python compatibility.
# %%time
# def get_extreme_points(pts: np.ndarray, ref_idx: int, rs: float):
#     tree = KDTree(pts)
#     pr = pts[ref_idx]
# 
#     candidates = []
# 
#     for i, pi in enumerate(pts):
#         if i == ref_idx:
#             continue
# 
#         nbr_idx = [j for j in tree.query_ball_point(pi, rs) if j != i]
#         if len(nbr_idx) == 0:
#             continue
# 
#         d1 = pr - pi
#         d1_norm = np.linalg.norm(d1)
#         if d1_norm == 0:
#             continue
#         d1_hat = d1 / d1_norm
# 
#         all_pos = True
#         for j in nbr_idx:
#             d2 = pts[j] - pi
#             d2_norm = np.linalg.norm(d2)
#             if d2_norm == 0:
#                 continue
#             d2_hat = d2 / d2_norm
# 
#             if np.dot(d1_hat, d2_hat) < 0:
#                 all_pos = False
#                 break
# 
#         if all_pos:
#             candidates.append((i, d1_norm, d1_hat))
# 
#     if len(candidates) < 2:
#         raise RuntimeError("Not enough extreme candidates found.")
# 
#     candidates.sort(key=lambda x: x[1])
#     e1_idx, e1_dist, e1_dir = candidates[0]
# 
#     opposite = [c for c in candidates[1:]
#                 if np.dot(e1_dir, c[2]) < 0]
#     if not opposite:
#         e2_idx = candidates[1][0]
#     else:
#         e2_idx = min(opposite, key=lambda x: x[1])[0]
# 
#     return e1_idx, e2_idx

# Commented out IPython magic to ensure Python compatibility.
# %%time
# def extract_all_edges(xyz_e, dist_thr=0.01, min_inliers=30, n_iter=200):
#     mask  = np.ones(len(xyz_e), bool)
#     edges = []
# 
#     while True:
#         idxs = np.where(mask)[0]
#         if len(idxs) < min_inliers:
#             break
# 
#         subset = xyz_e[idxs]
#         model, inliers = ransac_line(
#             subset,
#             n_iter=n_iter,
#             dist_thr=dist_thr,
#             min_inliers=min_inliers
#         )
#         if model is None:
#             break
# 
#         p0, v = model
# 
#         pts_inl = subset[inliers]
#         t_vals  = (pts_inl - p0).dot(v)
# 
#         i1, i2 = np.argmin(t_vals), np.argmax(t_vals)
#         orig_e1 = idxs[inliers[i1]]
#         orig_e2 = idxs[inliers[i2]]
# 
#         edges.append((orig_e1, orig_e2))
# 
#         mask[idxs[inliers]] = False
# 
#     residual = xyz_e[mask]
#     return edges, residual

# Commented out IPython magic to ensure Python compatibility.
# %%time
# xyz = cloud.points[['x','y','z']].values
# xyz_e = xyz[edge_mask]
# 
# A, residual = extract_all_edges(xyz_e, dist_thr=0.01, min_inliers=50, n_iter=200)
# 
# fig = plt.figure(figsize=(8,6))
# ax  = fig.add_subplot(111, projection='3d')
# ax.scatter(xyz_e[:,0], xyz_e[:,1], xyz_e[:,2],
#            c='lightgray', s=1, alpha=0.5, label='edge cloud E')
# for (i1,i2) in A:
#     p1, p2 = xyz_e[i1], xyz_e[i2]
#     ax.plot([p1[0],p2[0]],
#             [p1[1],p2[1]],
#             [p1[2],p2[2]],
#             linewidth=2, c='red')
# ax.set_xlabel('X'); ax.set_ylabel('Y'); ax.set_zlabel('Z')
# plt.title("Extracted 3D edges from E")
# plt.legend()
# plt.show()

"""## 4. Pose Refinement"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# def edge_dir(edge):
#     p, q = xyz_e[edge[0]], xyz_e[edge[1]]
#     return (q - p) / np.linalg.norm(q - p)
# 
# 
# def line_dist(ea, eb):
#     p1, d1 = xyz_e[ea[0]], edge_dir(ea)
#     p2, d2 = xyz_e[eb[0]], edge_dir(eb)
#     n = np.cross(d1, d2)
#     if np.linalg.norm(n) < 1e-6:
#         return np.inf
#     return abs(np.dot(n, p2 - p1)) / np.linalg.norm(n)
# 
# 
# def find_best_edge_pair(A):
#     scores = []
#     for ea, eb in itertools.combinations(A, 2):
#         alpha = abs(np.dot(edge_dir(ea), edge_dir(eb)))
#         delta = line_dist(ea, eb)
#         scores.append((tuple(ea), tuple(eb), alpha, delta))
#     scores.sort(key=lambda x: (x[2], x[3]))
#     return scores[0]
# 
# 
# def cluster_cube_edges(A, xyz_e, seed, inters_tol=5e-3):
#     ea, eb, _, _ = seed
#     def intersects(e1, e2):
#         return line_dist(e1, e2) < inters_tol
# 
#     C_full = set([ea, eb])
#     queue = deque([ea, eb])
#     while queue:
#         curr = queue.popleft()
#         d1 = edge_dir(curr)
#         for cand in A:
#             cand = tuple(cand)
#             if cand in C_full:
#                 continue
#             d2 = edge_dir(cand)
#             if abs(np.dot(d1, d2)) < 0.1 and intersects(curr, cand):
#                 C_full.add(cand)
#                 queue.append(cand)
#     d_axis1 = edge_dir(ea)
#     d_axis2 = edge_dir(eb)
#     d_axis3 = np.cross(d_axis1, d_axis2)
#     axes = [d_axis1, d_axis2, d_axis3]
#     groups = {0: [], 1: [], 2: []}
#     for e in C_full:
#         d = edge_dir(e)
#         scores = [abs(np.dot(d, ax)) for ax in axes]
#         idx = int(np.argmax(scores))
#         groups[idx].append(e)
#     C_final = []
#     for idx, segs in groups.items():
#         lengths = [(e, np.linalg.norm(xyz_e[e[1]] - xyz_e[e[0]])) for e in segs]
#         lengths.sort(key=lambda x: x[1], reverse=True)
#         if len(lengths) < 4:
#             raise RuntimeError(f"Axis {idx} only has {len(lengths)} segments; expected ‚â•4")
#         C_final.extend([e for e, _ in lengths[:4]])
#     return C_final

# Commented out IPython magic to ensure Python compatibility.
# %%time
# def intersect_lines(ea, eb, xyz_e):
# 
#     p1, p2 = xyz_e[ea[0]], xyz_e[eb[0]]
#     d1 = (xyz_e[ea[1]] - p1); d1 /= np.linalg.norm(d1)
#     d2 = (xyz_e[eb[1]] - p2); d2 /= np.linalg.norm(d2)
#     A = np.stack([d1, -d2], axis=1)    # 3√ó2
#     b = p2 - p1
#     uv, *_ = np.linalg.lstsq(A, b, rcond=None)
#     pt1 = p1 + uv[0]*d1
#     pt2 = p2 + uv[1]*d2
#     return (pt1 + pt2)/2

# Commented out IPython magic to ensure Python compatibility.
# %%time
# def pose_from_two_edges(e1, e2, xyz_e, dims):
#     ‚Ñì, b, h = dims
# 
#     p1 = intersect_lines(e1, e2, xyz_e)
#     pts1 = [xyz_e[e1[0]], xyz_e[e1[1]]]
#     pts2 = [xyz_e[e2[0]], xyz_e[e2[1]]]
# 
#     p2 = pts1[0] if np.linalg.norm(pts1[1]-p1) > np.linalg.norm(pts1[0]-p1) else pts1[1]
#     p3 = pts2[0] if np.linalg.norm(pts2[1]-p1) > np.linalg.norm(pts2[0]-p1) else pts2[1]
# 
#     obs_l = np.linalg.norm(p2 - p1)
#     obs_b = np.linalg.norm(p3 - p1)
#     if abs(obs_l - b) < abs(obs_l - ‚Ñì):
#         ‚Ñì, b = b, ‚Ñì
# 
#     d1 = (p2-p1); d1 /= np.linalg.norm(d1)
#     d2 = (p3-p1); d2 /= np.linalg.norm(d2)
#     t  = -p1 / np.linalg.norm(p1)
#     d  = np.cross(d1, d2); d /= np.linalg.norm(d)
# 
#     if np.dot(d, t) < 0:
#         d1f = -d1; df = np.cross(d1f, d2)
#         if np.dot(df, t) > 0:
#             d1, d = d1f, df/np.linalg.norm(df)
#         else:
#             d2 = -d2
#             d  = np.cross(d1, d2); d /= np.linalg.norm(d)
# 
#     R = np.stack([d1, d2, d], axis=1)
# 
#     local_p1 = np.array([-‚Ñì/2, -b/2, +h/2])
#     local_p2 = np.array([+‚Ñì/2, -b/2, +h/2])
#     local_p3 = np.array([-‚Ñì/2, +b/2, +h/2])
# 
#     T1 = p1 - R.dot(local_p1)
#     T2 = p2 - R.dot(local_p2)
#     T3 = p3 - R.dot(local_p3)
#     T  = (T1 + T2 + T3) / 3.0
# 
#     return R, T

# Commented out IPython magic to ensure Python compatibility.
# %%time
# import itertools
# from sklearn.cluster import KMeans
# def get_observed_corners(C, xyz_e, orth_tol=0.05):
#     directions = []
#     for e in C:
#         v = edge_dir(e)
#         added = False
#         for group in directions:
#             if abs(np.dot(group[0], v)) > 0.95:
#                 group.append(v)
#                 added = True
#                 break
#         if not added:
#             directions.append([v])
# 
#     points = set()
#     for e in C:
#         points.add(tuple(xyz_e[e[0]]))
#         points.add(tuple(xyz_e[e[1]]))
# 
#     unique = []
#     for p in map(np.array, points):
#         if not any(np.linalg.norm(p - q) < 1e-3 for q in unique):
#             unique.append(p)
#     return np.array(unique)
# 
# def refine_pose(R_init, T_init, C, xyz_e, dims):
#     obs = get_observed_corners(C, xyz_e)
#     l, b, h = dims
#     signs = list(itertools.product([-1,1], repeat=3))
#     model = np.array([[sx*l/2, sy*b/2, sz*h/2] for sx,sy,sz in signs])
#     preds = (R_init @ model.T).T + T_init
#     tol = max(l,b,h) * 0.1
#     corr = []
#     for ml, wp in zip(model, preds):
#         dists = np.linalg.norm(obs - wp, axis=1)
#         j = np.argmin(dists)
#         if dists[j] < tol:
#             corr.append((ml, obs[j]))
#     if len(corr) < 3:
#         print("‚ö†Ô∏è Too few correspondences; skipping refinement.")
#         return R_init, T_init
#     Ls = np.array([c[0] for c in corr])
#     Ws = np.array([c[1] for c in corr])
#     cL = Ls.mean(0)
#     cW = Ws.mean(0)
#     H  = (Ls - cL).T @ (Ws - cW)
#     U, S, Vt = np.linalg.svd(H)
#     R_ref = Vt.T @ U.T
#     if np.linalg.det(R_ref) < 0:
#         Vt[-1,:] *= -1
#         R_ref = Vt.T @ U.T
#     T_ref = cW - R_ref @ cL
#     return R_ref, T_ref

# Commented out IPython magic to ensure Python compatibility.
# %%time
# rs, th = 0.2, 0.42
# edge_mask, edge_scores = compute_edge_mask(cloud, rs, th)
# xyz     = cloud.points[['x', 'y', 'z']].values
# xyz_e   = xyz[edge_mask]
# A, _    = extract_all_edges(xyz_e, dist_thr=0.01, min_inliers=50, n_iter=200)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# seed = find_best_edge_pair(A)
# ea, eb, alpha, delta = seed
# print(f"Seed pair |dot|={alpha:.4f}, dist={delta:.4f}")
# 
# C = cluster_cube_edges(A, xyz_e, seed)
# print(f"Clustered edges: {len(C)}")
# 
# dims = (0.03, 0.03, 0.03)
# R_init, T_init = pose_from_two_edges(ea, eb, xyz_e, dims)
# print("Initial R:\n", R_init)
# print("Initial T:\n", T_init)
# 
# R_ref, T_ref = refine_pose(R_init, T_init, C, xyz_e, dims)
# print("Refined R:\n", R_ref)
# print("Refined T:\n", T_ref)
# 
# obs_c = get_observed_corners(C, xyz_e)
# model_c = np.array([[sx*dims[0]/2, sy*dims[1]/2, sz*dims[2]/2]
#                     for sx,sy,sz in itertools.product([-1,1], repeat=3)])
# world_c = (R_ref @ model_c.T).T + T_ref
# fig = plt.figure(figsize=(6,6))
# ax  = fig.add_subplot(111, projection='3d')
# ax.scatter(xyz_e[:,0], xyz_e[:,1], xyz_e[:,2], c='gray', s=1, alpha=0.2)
# ax.scatter(obs_c[:,0], obs_c[:,1], obs_c[:,2], c='red',   label='Obs Corners', s=40)
# ax.legend(); plt.title('Observed Corners'); plt.show()

"""

> Vohra, M., Prakash, R., & Behera, L. (2021). Edge and Corner Detection in Unorganized Point Clouds for Robotic Pick and Place Applications.

"""