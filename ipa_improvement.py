# -*- coding: utf-8 -*-
"""IPA_improvement.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KLX7SZxNLL_zdsNC7evj4X8ljmM-9IME

# Edge and Corner Detection in Unorganized Point Clouds
"""

!pip install pyntcloud
!pip install open3d

from pyntcloud import PyntCloud
import pandas as pd
import matplotlib.pyplot as plt
from scipy.spatial import KDTree
from sklearn.linear_model import RANSACRegressor
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import numpy as np
import open3d as o3d
from sklearn.cluster import DBSCAN
from collections import deque
from itertools import combinations

file_path = "/content/drive/MyDrive/Edge and Corner Detection in Unorganized Point Clouds/ArtificialPointClouds/Cube30KSharpEdge.pcd"
pcd = PyntCloud.from_file(file_path)

df = pcd.points

fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(df['x'], df['y'], df['z'], s=0.5)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
plt.title("Point Cloud")
plt.show()

"""## 1. Edge Points Extraction"""

def detect_edges(pcd: PyntCloud, k_n: int = 50, thresh: float = 0.03):
    kdtree_id = pcd.add_structure("kdtree")
    k_neighbors = pcd.get_neighbors(k=k_n, kdtree=kdtree_id)

    pcd.add_scalar_field("eigen_values", k_neighbors=k_neighbors)

    x = pcd.points['x'].values
    y = pcd.points['y'].values
    z = pcd.points['z'].values

    e1 = pcd.points[f'e3({k_n+1})'].values
    e2 = pcd.points[f'e2({k_n+1})'].values
    e3 = pcd.points[f'e1({k_n+1})'].values

    sum_ev = e1 + e2 + e3
    sigma = e1 / sum_ev
    sigma_value = sigma.copy()

    edge_mask = sigma > thresh

    pcd_np = np.zeros((len(x), 6))
    pcd_np[:, 0] = x
    pcd_np[:, 1] = y
    pcd_np[:, 2] = z

    sigma_value[sigma_value < thresh] = 0
    sigma_value[sigma_value >= thresh] = 255
    pcd_np[:, 3] = sigma_value

    df_full = pd.DataFrame(pcd_np, columns=['x','y','z','red','green','blue'])
    df_full['red'] = df_full['red'].astype(np.uint8)
    pcd_points = PyntCloud(df_full)

    edge_np = pcd_np[edge_mask]
    df_edges = pd.DataFrame(edge_np, columns=['x','y','z','red','green','blue'])
    edge_points = PyntCloud(df_edges)

    return pcd_points, edge_points

full_cloud, edges = detect_edges(pcd, k_n=50, thresh=0.06)

reds = full_cloud.points['red'].values
colors_full = np.where(reds > 0, 'red', 'blue')

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6), subplot_kw={'projection': '3d'})

ax1.scatter(full_cloud.points['x'], full_cloud.points['y'], full_cloud.points['z'],
            c=colors_full, s=1)
ax1.set_title('Full cloud (blue=non-edge, red=edge)')

ax2.scatter(edges.points['x'], edges.points['y'], edges.points['z'],
            c='red', s=2)
ax2.set_title('Extracted edge points')

plt.tight_layout()
plt.show()

"""## 2. Corner Detection"""

def detect_harris_corners(edge_cloud: PyntCloud,
                          normal_k: int = 20,
                          radius: float = 0.05,
                          k: float = 0.04,
                          min_neighbors: int = 10,
                          thresh: float = 0.01,
                          non_max_radius: float = 0.05):
    pts = edge_cloud.points
    xyz = np.vstack((pts['x'], pts['y'], pts['z'])).T
    tree = KDTree(xyz)
    N = len(xyz)

    normals = np.zeros_like(xyz)
    for i, p in enumerate(xyz):
        dist, idx = tree.query(p, k=normal_k)
        neigh = xyz[idx] - p
        cov = neigh.T.dot(neigh)
        _, vecs = np.linalg.eigh(cov)
        normals[i] = vecs[:, 0]

    R = np.zeros(N)
    for i, p in enumerate(xyz):
        idx = tree.query_ball_point(p, radius)
        if len(idx) < min_neighbors:
            continue
        diffs = normals[idx] - normals[i]
        H = diffs.T.dot(diffs)
        R[i] = np.linalg.det(H) - k * (np.trace(H) ** 2)

    R[R < 0] = 0
    if R.max() <= 0:
        return np.empty((0,3))
    R = R / R.max()
    cand = np.where(R >= thresh)[0]

    keep = []
    for i in cand:
        nbr = tree.query_ball_point(xyz[i], non_max_radius)
        if all(R[i] >= R[j] for j in nbr):
            keep.append(i)

    corners = xyz[keep]
    return corners

def find_extreme_corners(corners):
    extreme_corners = []
    for x in [np.min(corners[:, 0]), np.max(corners[:, 0])]:
        for y in [np.min(corners[:, 1]), np.max(corners[:, 1])]:
            for z in [np.min(corners[:, 2]), np.max(corners[:, 2])]:
                target = np.array([x, y, z])
                dists = np.linalg.norm(corners - target, axis=1)
                nearest_idx = np.argmin(dists)
                extreme_corners.append(corners[nearest_idx])
    return np.array(extreme_corners)

corners = detect_harris_corners(
    edge_cloud,
    normal_k=20,
    radius=0.05,
    k=0.04,
    min_neighbors=10,
    thresh=0.01,
    non_max_radius=0.05
)
print("Detected corners:", len(corners))
extreme_corners = find_extreme_corners(corners)
print("8 extreme corners found:\n", extreme_corners)


fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(corners[:, 0], corners[:, 1], corners[:, 2], c='red', s=10, label='Detected Corners')
ax.scatter(extreme_corners[:, 0], extreme_corners[:, 1], extreme_corners[:, 2], c='lime', s=80, label='Extreme Corners', edgecolors='k')
ax.legend()
ax.set_title('Extreme Corners from Detected Corners')
plt.show()

"""## 3. Pose Estimation"""

def estimate_pose_from_corners(corners, dims, eps=1e-6):
    coords = np.asarray(corners)

    key = coords[:,0] + coords[:,1] - coords[:,2]
    idx1 = np.argmin(key)
    p1 = coords[idx1]

    mask_x = (np.isclose(coords[:,1], p1[1], atol=eps) &
              np.isclose(coords[:,2], p1[2], atol=eps))
    pts_x = coords[mask_x]
    p2 = pts_x[np.argmax(pts_x[:,0])]

    mask_y = (np.isclose(coords[:,0], p1[0], atol=eps) &
              np.isclose(coords[:,2], p1[2], atol=eps))
    pts_y = coords[mask_y]
    p3 = pts_y[np.argmax(pts_y[:,1])]

    d1 = (p2 - p1) / np.linalg.norm(p2 - p1)
    d2 = (p3 - p1) / np.linalg.norm(p3 - p1)
    t_vec = -p1 / np.linalg.norm(p1)

    d3 = np.cross(d1, d2)
    d3 /= np.linalg.norm(d3)

    if np.dot(d3, t_vec) < 0:
        d2 = -d2
        d3 = np.cross(d1, d2)
        d3 /= np.linalg.norm(d3)

    R = np.column_stack((d1, d2, d3))

    l, b, h = dims
    p1_local = np.array([-l/2, -b/2,  h/2])
    t = p1 - R.dot(p1_local)

    return R, t, p1, (d1, d2, d3)

